local modules = peripheral.find("neuralInterface")
if not modules then
	error("Must have a neural interface", 0)
end

-- Check for required modules
if not modules.hasModule("plethora:laser") then error("Cannot find laser", 0) end
if not modules.hasModule("plethora:sensor") then error("Cannot find entity sensor", 0) end

-- Function to fire a laser at an entity
local function fire(entity)
	local x, y, z = entity.x, entity.y, entity.z
	local pitch = -math.atan2(y, math.sqrt(x * x + z * z))
	local yaw = math.atan2(-x, z)
	modules.fire(math.deg(yaw), math.deg(pitch), 5)
	sleep(0.2)
end

-- Tracking list and sentry state
local trackedEntities = { "corruption_avatar", "Creeper", "Zombie", "Skeleton" }
local isSentryOn = true

-- Convert trackedEntities to a lookup table
local function buildLookup(entities)
	local lookup = {}
	for i = 1, #entities do
		lookup[entities[i]] = true
	end
	return lookup
end

local mobLookup = buildLookup(trackedEntities)

-- Add an entity to the tracking list
local function addEntity(entity)
	if not mobLookup[entity] then
		table.insert(trackedEntities, entity)
		mobLookup[entity] = true
		print(entity .. " added to tracking list.")
	else
		print(entity .. " is already in the tracking list.")
	end
end

-- Remove an entity from the tracking list
local function removeEntity(entity)
	if mobLookup[entity] then
		for i = #trackedEntities, 1, -1 do
			if trackedEntities[i] == entity then
				table.remove(trackedEntities, i)
			end
		end
		mobLookup[entity] = nil
		print(entity .. " removed from tracking list.")
	else
		print(entity .. " is not in the tracking list.")
	end
end

-- Toggle the sentry on or off
local function toggleSentry()
	isSentryOn = not isSentryOn
	if isSentryOn then
		print("Sentry is now ON.")
	else
		print("Sentry is now OFF.")
	end
end

-- Function to display the current status
local function displayStatus()
	print("Sentry Status: " .. (isSentryOn and "ON" or "OFF"))
	print("Tracked Entities: ")
	for _, entity in ipairs(trackedEntities) do
		print(" - " .. entity)
	end
end

-- Function to save the current configuration
local function saveConfig()
	local config = {
		isSentryOn = isSentryOn,
		trackedEntities = trackedEntities
	}
	local file = fs.open("sentry_config", "w")
	file.write(textutils.serialize(config))
	file.close()
	print("Configuration saved.")
end

-- Function to load the configuration
local function loadConfig()
	if fs.exists("sentry_config") then
		local file = fs.open("sentry_config", "r")
		local config = textutils.unserialize(file.readAll())
		file.close()
		isSentryOn = config.isSentryOn
		trackedEntities = config.trackedEntities
		mobLookup = buildLookup(trackedEntities)
		print("Configuration loaded.")
	else
		print("No configuration file found.")
	end
end

-- Function to check for and attack tracked entities
local function checkAndAttack()
	while true do
		if isSentryOn then
			local mobs = modules.sense()
			local candidates = {}
			for i = 1, #mobs do
				local mob = mobs[i]
				if mobLookup[mob.name] then
					candidates[#candidates + 1] = mob
				end
			end

			if #candidates > 0 then
				local mob = candidates[math.random(1, #candidates)]
				fire(mob)
			else
				sleep(1)
			end
		else
			sleep(1)
		end
	end
end

-- Function to get user input for controlling the sentry
local function userInput()
	while true do
		print("Menu:")
		print("1. Add entity to tracking list")
		print("2. Remove entity from tracking list")
		print("3. Toggle sentry on/off")
		print("4. Display status")
		print("5. Save configuration")
		print("6. Load configuration")
		print("7. Exit")
		print("Enter your choice:")

		local choice = tonumber(read())
		
		if choice == 1 then
			print("Enter entity name to add:")
			local entity = read()
			addEntity(entity)
		elseif choice == 2 then
			print("Enter entity name to remove:")
			local entity = read()
			removeEntity(entity)
		elseif choice == 3 then
			toggleSentry()
		elseif choice == 4 then
			displayStatus()
		elseif choice == 5 then
			saveConfig()
		elseif choice == 6 then
			loadConfig()
		elseif choice == 7 then
			break
		else
			print("Invalid choice. Try again.")
		end
	end
end

-- Parallel execution of the sentry's operations and user input
parallel.waitForAny(checkAndAttack, userInput)
