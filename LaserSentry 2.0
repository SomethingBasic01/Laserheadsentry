local modules = peripheral.find("neuralInterface")
if not modules then
	error("Must have a neural interface", 0)
end

-- Check for required modules
if not modules.hasModule("plethora:laser") then error("Cannot find laser", 0) end
if not modules.hasModule("plethora:sensor") then error("Cannot find entity sensor", 0) end

-- Function to fire a laser at an entity
local function fire(entity)
	local x, y, z = entity.x, entity.y, entity.z
	local pitch = -math.atan2(y, math.sqrt(x * x + z * z))
	local yaw = math.atan2(-x, z)
	modules.fire(math.deg(yaw), math.deg(pitch), 5)
	sleep(0.2)
end

-- Tracking list and sentry state
local trackedEntities = { "corruption_avatar", "Creeper", "Zombie", "Skeleton" }
local isSentryOn = true

-- Convert trackedEntities to a lookup table
local function buildLookup(entities)
	local lookup = {}
	for i = 1, #entities do
		lookup[entities[i]] = true
	end
	return lookup
end

local mobLookup = buildLookup(trackedEntities)

-- Add an entity to the tracking list
local function addEntity(entity)
	if not mobLookup[entity] then
		table.insert(trackedEntities, entity)
		mobLookup[entity] = true
		print(entity .. " added to tracking list.")
	else
		print(entity .. " is already in the tracking list.")
	end
end

-- Remove an entity from the tracking list
local function removeEntity(entity)
	if mobLookup[entity] then
		for i = #trackedEntities, 1, -1 do
			if trackedEntities[i] == entity then
				table.remove(trackedEntities, i)
			end
		end
		mobLookup[entity] = nil
		print(entity .. " removed from tracking list.")
	else
		print(entity .. " is not in the tracking list.")
	end
end

-- Toggle the sentry on or off
local function toggleSentry()
	isSentryOn = not isSentryOn
	if isSentryOn then
		print("Sentry is now ON.")
	else
		print("Sentry is now OFF.")
	end
end

-- Function to check for and attack tracked entities
local function checkAndAttack()
	while true do
		if isSentryOn then
			local mobs = modules.sense()
			local candidates = {}
			for i = 1, #mobs do
				local mob = mobs[i]
				if mobLookup[mob.name] then
					candidates[#candidates + 1] = mob
				end
			end

			if #candidates > 0 then
				local mob = candidates[math.random(1, #candidates)]
				fire(mob)
			else
				sleep(1)
			end
		else
			sleep(1)
		end
	end
end

-- Function to get user input for controlling the sentry
local function userInput()
	while true do
		print("Enter command: add <entity>, remove <entity>, toggle, or exit")
		local input = read()
		local command, entity = input:match("^(%S+)%s*(%S*)$")
		
		if command == "add" and entity ~= "" then
			addEntity(entity)
		elseif command == "remove" and entity ~= "" then
			removeEntity(entity)
		elseif command == "toggle" then
			toggleSentry()
		elseif command == "exit" then
			break
		else
			print("Invalid command. Try again.")
		end
	end
end

-- Parallel execution of the sentry's operations and user input
parallel.waitForAny(checkAndAttack, userInput)
